<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      Function.prototype.before = function (fn) {
        const self = this;
        return function () {
          fn();
          self.apply(this, arguments);
        };
      };
      Function.prototype.after = function (fn) {
        const self = this;
        return function () {
          self.apply(this, arguments);
          fn();
        };
      };

      class Symbols {
        static container = Symbol.for('kotori.context.container');
        static containerKey = (prop) => Symbol.for(`kotori.context.container.${prop}`);
      }

      class Context {
        static handler() {
          return {
            get(target, prop, receiver) {
              if (prop === 'identity') return Reflect.get(target, Symbols.set).get(target);
              return Reflect.get(target, prop, receiver);
            }
          };
        }

        [Symbols.container] = new Map();
        [Symbols.set] = new WeakMap();

        root;

        constructor(config = {}) {
          this.root = config.root || this;
        }

        get(prop) {
          return this[Symbols.container].get(prop);
        }

        inject(prop, value) {
          const key = value ? Symbols.containerKey(prop) : prop;
          if (value) {
            if (this[Symbols.container].has(key)) return;
            this.provide(key, value);
          } else {
            if (!this[Symbols.container].has(key)) return;
          }
          if (key in this) return;
          this[prop] = this.get(key);
        }

        provide(prop, value) {
          if (this[Symbols.container].has(prop)) return;
          this[Symbols.container].set(prop, value);
        }

        mixin(prop, keys) {
          if (!this[Symbols.container].has(prop)) return;
          keys.forEach((key) => {
            if (key in this) return;
            const instance = this.get(prop);
            if (!instance) return;
            if (!(key in instance)) return;
            if (typeof this.get(prop)[key] === 'function') {
              this[key] = this.get(prop)[key].bind(this.get(prop));
              return;
            }
            this[key] = this.get(prop)[key];
          });
        }

        extends(meta = {}, identity = 'sub') {
          const metaHandle = meta;
          Object.keys(metaHandle).forEach((key) => {
            if (typeof this[key] === 'function') delete metaHandle[key];
          });
          const ctx = Object.assign(new Context(this.root), this, meta, { identity });
          ctx[Symbols.container].forEach((value, key) => {
            if (!('ctx' in value)) {
              ctx[Symbols.container].set(key, value);
              return;
            }
            const instance = Object.assign(value, { ctx });
            ctx[Symbols.container].set(key, instance);
          });
          return ctx;
        }

        proxy() {
          return new Proxy(this, Context.handler);
        }
      }
      class Event {
        #stack = new Set();
        heart = 114514;
        ctx;
        constructor(ctx) {
          this.ctx = ctx;
        }
        on(callback) {
          this.#stack.add(callback);
        }
        emit() {
          // console.log(this.heart);
          console.log(`identity ->`, this.ctx.identity);
          this.#stack.forEach((callback) => callback());
        }
      }
      class Kotori extends Context {
        options;
        constructor(options) {
          super();
          const event = new Event(this);
          this.provide('event', event);
          this.mixin('event', ['emit', 'on']);
          this.options = options;
        }
      }
      const ctx = new Kotori({ v: 1 });
      // event.emit();
      // ctx.inject('event').emit();
      ctx.emit();
      // console.log(ctx.options);
      ctx.on(() => console.log(''));
      // ctx.emit();
      const ctx2 = ctx.extends({ options: 2 });
      // console.log(ctx.options, ctx2.options);
      // ctx2.inject('event').on(() => console.log('nb from ctx2 with inject'));
      ctx2.emit();
      ctx2.extends({}, 23).on(() => console.log('by ctx2'));
      ctx2.extends({}, 233).get('event').emit();
      ctx2.extends({}, 2333).emit();
      // const ctx3 = ctx2.extends();
      // const ctx4 = ctx.extends();
      // ctx2.inject('event').emit();
      // console.log(ctx3.options, ctx4.options, ctx4);
      // console.log(ctx.identity, ctx2.get('event'), ctx2[Symbols.container]);

      /*       ctx2.provide('cc', { f: () => console.log('cc') }); */
      const ctx3 = ctx2.extends({ options: 3, emit: 1 }, 'ccc');
      ctx2.inject('cc', () => console.log('cc'));
      console.log(ctx2.identity, ctx.identity, ctx3.identity, ctx2.extends().identity);
    </script>
  </body>
</html>
