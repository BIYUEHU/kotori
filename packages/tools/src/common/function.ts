import { obj } from '../types';

/* declare global {
  interface Function {
    before(fn: Function): Function;
    after(fn: Function): Function;
  }
} */

/* eslint no-extend-native: 0 */
/* eslint func-names: 0 */
/* Function.prototype.before = function (fn) {
  const self = this;
  return function (...args: unknown[]) {
    fn();
    self.apply(this, args);
  };
};

Function.prototype.after = function (fn) {
  const self = this;
  return function (...args: unknown[]) {
    self.apply(this, args);
    fn();
  };
}; */

/* export const initialize: MethodDecorator = (_, __, val) => {
	if (val.value instanceof Function) val.value();
}; */

export function none(..._: unknown[]) {
  _.length.toString();
}

export function isClass(obj: unknown, strict: boolean = true): obj is new (...args: unknown[]) => unknown {
  if (typeof obj !== 'function') return false;

  const str = obj.toString();

  // async function or arrow function
  if (obj.prototype === undefined) return false;
  // generator function or malformed definition
  if (obj.prototype.constructor !== obj) return false;
  // ES6 class
  if (str.slice(0, 5) === 'class') return true;
  // has own prototype properties
  if (Object.getOwnPropertyNames(obj.prototype).length >= 2) return true;
  // anonymous function
  if (/^function\s+\(|^function\s+anonymous\(/.test(str)) return false;
  // ES5 class without `this` in the body and the name's first character
  // upper-cased.
  if (strict && /^function\s+[A-Z]/.test(str)) return true;
  // has `this` in the body
  if (/\b\(this\b|\bthis[.[]\b/.test(str)) {
    // not strict or ES5 class generated by babel
    if (!strict || /classCallCheck\(this/.test(str)) return true;

    return /^function\sdefault_\d+\s*\(/.test(str);
  }

  return false;
}

export function clearObject(val: obj, strict: boolean = false, stacks: Set<unknown> = new Set()) {
  const handle = val;
  Object.keys(handle).forEach((key) => {
    if (handle[key] !== undefined && (strict || handle[key] !== null)) {
      if (typeof handle[key] === 'object' && stacks.has(handle[key])) handle[key] = clearObject(handle[key]);
      return;
    }
    delete handle[key];
  });
  return handle;
}

export function stringRightSplit(str: string, key: string): string {
  const index = str.indexOf(key);
  return str.slice(index + key.length);
}

export function stringTemp(template: string, args: obj<string | number>) {
  const params = Object.assign(args, { break: '\n' });
  let templateString = template;
  if (!params || typeof params !== 'object') return templateString;
  Object.keys(params).forEach((param) => {
    if (typeof params[param] !== 'string' && typeof args[param] !== 'number') params[param] = '';
    if (params[param]?.toString instanceof Function) params[param] = (params[param] as number).toString();
    templateString = templateString.replace(new RegExp(`%${param}%`, 'g'), params[param] as string);
  });
  return templateString;
}

export function formatTime(date?: Date | null, format: number = 0) {
  /* Rewrite Base on Locale */
  const time = date || new Date();
  let result: string = '';
  if (format === 0) {
    result += `${time.getFullYear().toString().substring(2)}/`;
    result += `${time.getMonth() + 1}/${time.getDate()} `;
    result += `${time.getHours()}:${time.getMinutes()}:${time.getMinutes()}`;
  } else if (format === 1) {
    result += `${time.getFullYear()}-${time.getMonth() + 1}-${time.getDate()}`;
  }
  return result;
}

export function getDate() {
  const TIME = new Date();
  const date = TIME.getDate();
  const time = `${TIME.getFullYear()}-${TIME.getMonth() + 1}-${date}`;
  return time;
}

export function getSpecStr(template: string) {
  return template.replace(/[xy]/g, (char) => {
    const r = Math.random() * 16;
    let v: number | string;
    if (char === 'x') {
      v = Math.floor(r);
    } else {
      v = (Math.floor(r) % 4) + 8;
    }
    return v.toString(16);
  });
}

export function getUuid(): string {
  return getSpecStr('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx');
}

export function getRandomStr(): string {
  return getSpecStr('xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx');
}

export function getRandomInt(max: number, min: number = 0): number {
  const range = max - min + 1;
  const index = Math.floor(Math.random() * range);
  const result = min + index;
  return result;
}

export function createProxy<T extends object>(val: T | (() => T)) {
  return new Proxy({} as T, {
    get: (_target, property) => {
      let value = val;
      if (typeof val === 'function') value = val();
      return value[property as keyof typeof val];
    }
  });
}

export function parseArgs(command: string) {
  const args: string[] = [];
  let current = '';
  let inQuote = false;
  let quoteChar: null | string = null;
  let lastQuoteChar: null | string = null;
  for (let i = 0; i < command.length; i += 1) {
    let c = command[i];
    if (inQuote) {
      if (c === quoteChar) {
        inQuote = false;
        quoteChar = null;
      } else if (c === '\\' && i + 1 < command.length) {
        i += 1;
        c = command[i];
        if (c === '"' || c === "'") {
          current += c;
        } else {
          current += `\\${c}`;
        }
      } else {
        current += c;
      }
    } else if (c === '"' || c === "'") {
      inQuote = true;
      quoteChar = c;
      lastQuoteChar = c;
    } else if (c === ' ' && current) {
      args.push(current);
      current = '';
    } else {
      current += c;
    }
  }
  if (inQuote || quoteChar) return { char: lastQuoteChar!, index: command.lastIndexOf(lastQuoteChar!)! };
  if (current) args.push(current);
  return args;
}

/* export const isObj = <T = any>(data: unknown): data is obj<T> => {
	const result = data && typeof data === 'object' && !Array.isArray(data);
	if (!result) return false;
  	for (const element of Object.keys(result)) {
		if (!element as T) return false;
	}
	return true;
}; */
